#include <WiFi.h>
#include <esp_now.h>
#include <ESP32Servo.h>

/* ================= CONFIG ================= */

#define SERVO_COUNT 6
#define UPDATE_INTERVAL 10
#define STEP_SIZE 1
#define THUMB_INDEX 0
#define THUMB_MIRROR_INDEX 5

/* ================= DATA PACKET ================= */

typedef struct {
  int fingerCode;
} FingerPacket;

/* ================= SERVO STRUCT ================= */

struct ServoUnit {
  Servo motor;
  uint8_t pin;
  int minAngle;
  int maxAngle;
  int currentAngle;
  int targetAngle;
};

/* ================= SERVO CONFIG ================= */

ServoUnit servos[SERVO_COUNT] = {
  {Servo(),13,0,100,90,90},   // Thumb
  {Servo(),12,0,130,90,90},   // Index
  {Servo(),14,0,160,90,90},   // Middle
  {Servo(),27,0,170,90,90},   // Ring
  {Servo(),26,0,130,90,90},   // Little
  {Servo(),25,45,140,90,90}    // Thumb Mirror Servo
};

unsigned long previousMillis = 0;

/* ================= SERVO FUNCTIONS ================= */

void initServos() {
  for(int i=0;i<SERVO_COUNT;i++){
    servos[i].motor.attach(servos[i].pin);
    servos[i].motor.write(servos[i].currentAngle);
  }
}

void setServoTarget(int index,int angle){

  if(index<0 || index>=SERVO_COUNT) return;

  angle = constrain(angle,
                    servos[index].minAngle,
                    servos[index].maxAngle);

  servos[index].targetAngle = angle;
}

void updateServoMotion(){

  for(int i=0;i<SERVO_COUNT;i++){

    if(servos[i].currentAngle < servos[i].targetAngle)
      servos[i].currentAngle += STEP_SIZE;

    else if(servos[i].currentAngle > servos[i].targetAngle)
      servos[i].currentAngle -= STEP_SIZE;

    servos[i].motor.write(servos[i].currentAngle);
  }
}

/* ================= DIGIT DECODER ================= */

void applyFingerCode(int code){

  for(int i=4;i>=0;i--){   // only decode 5 digits

    int digit = code % 10;
    code /= 10;

    if(digit==1){

      setServoTarget(i, servos[i].maxAngle);

      // Mirror thumb behaviour
      if(i==THUMB_INDEX){
        setServoTarget(THUMB_MIRROR_INDEX,
                       servos[THUMB_MIRROR_INDEX].minAngle);
      }

    }
    else{

      setServoTarget(i, servos[i].minAngle);

      if(i==THUMB_INDEX){
        setServoTarget(THUMB_MIRROR_INDEX,
                       servos[THUMB_MIRROR_INDEX].maxAngle);
      }
    }
  }
}

/* ================= ESPNOW CALLBACK ================= */

void onDataRecv(const uint8_t *mac,
                const uint8_t *incomingData,
                int len) {

  FingerPacket packet;
  memcpy(&packet, incomingData, sizeof(packet));

  Serial.print("Received Code: ");
  Serial.println(packet.fingerCode);

  applyFingerCode(packet.fingerCode);
}

/* ================= SETUP ================= */

void setup(){

  Serial.begin(9600);

  initServos();

  WiFi.mode(WIFI_STA);

  if(esp_now_init()!=ESP_OK){
    Serial.println("ESP-NOW Init Failed");
    return;
  }

  esp_now_register_recv_cb(onDataRecv);

  Serial.println("Robotic Hand Controller + Thumb Mirror Ready");
}

/* ================= LOOP ================= */

void loop(){

  unsigned long currentMillis = millis();

  if(currentMillis - previousMillis >= UPDATE_INTERVAL){

    previousMillis = currentMillis;
    updateServoMotion();
  }
}
